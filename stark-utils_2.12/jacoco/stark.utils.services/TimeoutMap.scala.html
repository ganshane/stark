<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimeoutMap.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stark Utils Support</a> &gt; <a href="index.source.html" class="el_package">stark.utils.services</a> &gt; <span class="el_source">TimeoutMap.scala</span></div><h1>TimeoutMap.scala</h1><pre class="source lang-java linenums">// Copyright 2014,2015,2016 the original author or authors. All rights reserved.
// site: http://www.ganshane.com
package stark.utils.services

import java.util
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{ConcurrentHashMap, LinkedBlockingDeque}

/**
 * timeout map
 */
trait TimeoutMap[K, V] {
  def containsKey(key: K): Boolean

  def get(key: K): Option[V]

  def putHead(key: K, value: V)

  def put(key: K, value: V)

  def remove(key: K): Option[V]

  def size: Int
}

abstract trait ExpiredCallback[K, V] {
  def expire(key: K, value: V)
}

/**
 * RotatingMap must be used under thread-safe environment
 *
 * Expires keys that have not been updated in the configured number of seconds.
 * The algorithm used will take between expirationSecs and expirationSecs * (1 +
 * 1 / (numBuckets-1)) to actually expire the message.
 *
 * get, put, remove, containsKey, and size take O(numBuckets) time to run.
 *
 */
<span class="nc" id="L40">object RotatingMap {</span>
<span class="nc" id="L41">  val DEFAULT_NUM_BUCKETS: Int = 3</span>
}

<span class="pc" id="L44">class RotatingMap[K, V] extends TimeoutMap[K, V] {</span>
<span class="fc" id="L45">  private val flag = new AtomicBoolean(false)</span>
<span class="fc" id="L46">  private var _buckets: util.Deque[java.util.Map[K, V]] = null</span>
<span class="fc" id="L47">  private var _callback: ExpiredCallback[K, V] = null</span>

<span class="fc" id="L49">  def this(numBuckets: Int, callback: ExpiredCallback[K, V], isSingleThread: Boolean) {</span>
<span class="fc" id="L50">    this()</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">    if (numBuckets &lt; 2) {</span>
<span class="nc" id="L52">      throw new IllegalArgumentException(&quot;numBuckets must be &gt;= 2&quot;)</span>
    }
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">    if (isSingleThread) {</span>
<span class="nc" id="L55">      _buckets = new util.LinkedList[java.util.Map[K, V]]</span>
    }
    else {
<span class="fc" id="L58">      _buckets = new LinkedBlockingDeque[java.util.Map[K, V]]</span>
    }

<span class="fc" id="L61">    0 until numBuckets foreach { case i =&gt;</span>
<span class="fc" id="L62">      _buckets.add(new ConcurrentHashMap[K, V])</span>
    }
<span class="fc" id="L64">    _callback = callback</span>
  }

<span class="nc" id="L67">  def this(callback: ExpiredCallback[K, V]) {</span>
<span class="nc" id="L68">    this(RotatingMap.DEFAULT_NUM_BUCKETS, callback, false)</span>
  }

<span class="fc" id="L71">  def this(numBuckets: Int) {</span>
<span class="fc" id="L72">    this(numBuckets, null, false)</span>
  }

  def rotate: Option[java.util.Map[K, V]] = {
<span class="fc bfc" id="L76" title="All 2 branches covered.">    if (flag.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L78">        val dead: java.util.Map[K, V] = _buckets.removeLast()</span>
<span class="fc" id="L79">        _buckets.addFirst(new ConcurrentHashMap[K, V])</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if (_callback != null) {</span>
<span class="nc" id="L81">          val it = dead.entrySet().iterator()</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">          while (it.hasNext) {</span>
<span class="nc" id="L83">            val entry = it.next()</span>
<span class="nc" id="L84">            _callback.expire(entry.getKey, entry.getValue)</span>
          }
        }
<span class="fc" id="L87">        return Some(dead)</span>
      } finally {
<span class="fc" id="L89">        flag.set(false)</span>
      }
    }
<span class="fc" id="L92">    None</span>
  }

  def containsKey(key: K): Boolean = {
<span class="nc" id="L96">    val it = _buckets.iterator()</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">    while (it.hasNext) {</span>
<span class="nc" id="L98">      val bucket = it.next()</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      if (bucket.containsKey(key))</span>
<span class="nc" id="L100">        return true</span>
    }
<span class="nc" id="L102">    false</span>
  }

  def get(key: K): Option[V] = {
<span class="nc" id="L106">    val it = _buckets.iterator()</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">    while (it.hasNext) {</span>
<span class="nc" id="L108">      val bucket = it.next()</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (bucket.containsKey(key))</span>
<span class="nc" id="L110">        return Some(bucket.get(key))</span>
    }
<span class="nc" id="L112">    None</span>
  }

  def putHead(key: K, value: V) {
<span class="nc" id="L116">    _buckets.peekFirst.put(key, value)</span>
  }

  def put(key: K, value: V) {
<span class="fc" id="L120">    val it = _buckets.iterator</span>
<span class="fc" id="L121">    var bucket = it.next</span>
<span class="fc" id="L122">    bucket.put(key, value)</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">    while (it.hasNext) {</span>
<span class="fc" id="L124">      bucket = it.next</span>
<span class="fc" id="L125">      bucket.remove(key)</span>
    }
  }

  /**
   * Remove item from Rotate
   *
   * On the side of performance, scanning from header is faster On the side of
   * logic, it should scan from the end to first.
   *
   * @param key
   * @return
   */
  def remove(key: K): Option[V] = {
<span class="nc" id="L139">    val it = _buckets.iterator()</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">    while (it.hasNext) {</span>
<span class="nc" id="L141">      val bucket = it.next()</span>
<span class="nc" id="L142">      val value = bucket.remove(key)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (value != null)</span>
<span class="nc" id="L144">        return Some(value)</span>
    }
<span class="nc" id="L146">    None</span>
  }

  def size: Int = {
<span class="fc" id="L150">    var size: Int = 0</span>
<span class="fc" id="L151">    val it = _buckets.iterator()</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    while (it.hasNext) {</span>
<span class="fc" id="L153">      size += it.next().size()</span>
    }
<span class="fc" id="L155">    size</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>