<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JettyServerCreator.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stark Utils Support</a> &gt; <a href="index.source.html" class="el_package">stark.utils.services</a> &gt; <span class="el_source">JettyServerCreator.scala</span></div><h1>JettyServerCreator.scala</h1><pre class="source lang-java linenums">// Copyright 2014,2015,2016 the original author or authors. All rights reserved.
// site: http://www.ganshane.com
package stark.utils.services

import java.net.BindException
import java.util
import java.util.concurrent._
import javax.servlet.{DispatcherType, ServletContext}

import org.apache.tapestry5.TapestryFilter
import org.apache.tapestry5.internal.InternalConstants
import org.eclipse.jetty.server.nio.SelectChannelConnector
import org.eclipse.jetty.server.{Connector, Server}
import org.eclipse.jetty.servlet.{DefaultServlet, FilterHolder, ServletContextHandler, ServletHolder}
import org.eclipse.jetty.util.thread.QueuedThreadPool

<span class="nc" id="L17">trait JettyServerSupport {</span>
<span class="nc" id="L18">  private var modules: Option[Array[Class[_]]] = None</span>
<span class="nc" id="L19">  private var serverOpt: Option[Server] = None</span>

  protected def startServer(config: WebServerConfig, pkg: String, classes: Class[_]*): Server = {
<span class="nc" id="L22">    this.modules = Some(classes.toArray)</span>
    try {
<span class="nc" id="L24">      val bind = StarkUtils.parseBind(config.bind)</span>
<span class="nc" id="L25">      val server = JettyServerCreator.createTapestryWebapp(bind._1, bind._2, pkg, &quot;monad&quot;, new MonadTapestryFilter)</span>
<span class="nc" id="L26">      JettyServerCreator.configServer(server, config)</span>
<span class="nc" id="L27">      server.start()</span>
<span class="nc" id="L28">      serverOpt = Some(server)</span>
<span class="nc" id="L29">      server</span>
    } catch {
      case e: BindException =&gt;
<span class="nc" id="L32">        throw new StarkException(e.getMessage, StarkUtilsErrorCode.SERVER_FAIL_BIND)</span>
    }
  }

  protected def join() {
<span class="nc" id="L37">    serverOpt.foreach(_.join())</span>
  }

  protected def shutdownServer() {
<span class="nc" id="L41">    serverOpt.foreach(_.stop())</span>
  }

<span class="nc bnc" id="L44" title="All 2 branches missed.">  class MonadTapestryFilter extends TapestryFilter {</span>
    override def provideExtraModuleClasses(context: ServletContext): Array[Class[_]] = {
<span class="nc" id="L46">      modules match {</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">        case Some(m) =&gt;</span>
<span class="nc" id="L48">          m</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L50">          super.provideExtraModuleClasses(context)</span>
      }
    }
  }

}

/**
 * jetty servelt container
 */
<span class="nc" id="L60">object JettyServerCreator {</span>
  /**
   * 创建tapestry的webapp程序
   * @param port 端口
   * @param pkg tapestry package
   * @param appName 服务器实例
   * @param filter filter全路径
   * @return server instance
   */
  def createTapestryWebapp(host: String,
                           port: Int,
                           pkg: String,
<span class="nc" id="L72">                           appName: String = &quot;tapestry&quot;,</span>
<span class="nc" id="L73">                           filter: TapestryFilter = new TapestryFilter): Server = {</span>
    //TODO 提前校验端口是否被占用
<span class="nc" id="L75">    val server = new Server()</span>
    //对connector进行配置
<span class="nc" id="L77">    val connector = new SelectChannelConnector</span>
<span class="nc" id="L78">    connector.setHost(host)</span>
<span class="nc" id="L79">    connector.setPort(port)</span>


<span class="nc" id="L82">    server.setConnectors(Array[Connector](connector))</span>


<span class="nc" id="L85">    server.setSendServerVersion(false)</span>
<span class="nc" id="L86">    val context = new ServletContextHandler(ServletContextHandler.SESSIONS)</span>
<span class="nc" id="L87">    context.setContextPath(&quot;/&quot;)</span>
<span class="nc" id="L88">    context.setDisplayName(appName)</span>
<span class="nc" id="L89">    context.setInitParameter(InternalConstants.TAPESTRY_APP_PACKAGE_PARAM, pkg)</span>
    //default servlet holder
<span class="nc" id="L91">    val servletHolder = new ServletHolder(classOf[DefaultServlet])</span>
<span class="nc" id="L92">    servletHolder.setName(&quot;default&quot;)</span>
<span class="nc" id="L93">    context.addServlet(servletHolder, &quot;/&quot;)</span>

    //tapestry filter
<span class="nc" id="L96">    val filterHolder = new FilterHolder(filter)</span>
<span class="nc" id="L97">    filterHolder.setName(appName)</span>


<span class="nc" id="L100">    val all = util.EnumSet.allOf(classOf[DispatcherType])</span>
<span class="nc" id="L101">    context.addFilter(filterHolder, &quot;/*&quot;, all)</span>
<span class="nc" id="L102">    server.setHandler(context)</span>
<span class="nc" id="L103">    server</span>
  }

  def configServer(server: Server, webServerConfig: WebServerConfig) {
    /*
    val executorService = ThreadPoolCreator.newSaturatingThreadPool(
      webServerConfig.minConnCount,
      webServerConfig.maxConnCount,
      webServerConfig.waitingQueueSize,
      webServerConfig.keepAliveTimeInMinutes,
      TimeUnit.MINUTES,
      &quot;monad-web&quot;,
      new RejectedExecutionHandler {
        override def rejectedExecution(r: Runnable, executor: ThreadPoolExecutor): Unit = {
          throw new RejectedExecutionException(&quot;reach max connection&quot;)
        }
      })
    val threadPool = new ExecutorThreadPool(executorService)
    */
<span class="nc" id="L122">    val threadPool = new QueuedThreadPool(new ArrayBlockingQueue[Runnable](6000))</span>
<span class="nc" id="L123">    threadPool.setMinThreads(webServerConfig.minConnCount)</span>
<span class="nc" id="L124">    threadPool.setMaxThreads(webServerConfig.maxConnCount)</span>
<span class="nc" id="L125">    threadPool.setMaxIdleTimeMs(TimeUnit.MINUTES.toMillis(webServerConfig.keepAliveTimeInMinutes).asInstanceOf[Int])</span>
<span class="nc" id="L126">    threadPool.setDaemon(true)</span>

<span class="nc" id="L128">    server.setThreadPool(threadPool)</span>

<span class="nc" id="L130">    val connector = server.getConnectors.head.asInstanceOf[SelectChannelConnector]</span>
    //connector.setAcceptors(Math.max(1, (Runtime.getRuntime.availableProcessors + 3) / 4))

<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (webServerConfig.acceptor == 0)</span>
<span class="nc" id="L134">      connector.setAcceptors(Math.min(4, Runtime.getRuntime.availableProcessors + 3) / 4)</span>
    else
<span class="nc" id="L136">      connector.setAcceptors(webServerConfig.acceptor)</span>
<span class="nc" id="L137">    connector.setAcceptQueueSize(webServerConfig.backlog)</span>
<span class="nc" id="L138">    connector.setMaxIdleTime(webServerConfig.idleTimeSecs * 1000)</span>
<span class="nc" id="L139">    connector.setRequestBufferSize(webServerConfig.requestBufferSizeKB * 1024)</span>
<span class="nc" id="L140">    connector.setResponseBufferSize(webServerConfig.responseBufferSizeKB * 1024)</span>


    //graceful shutdown
<span class="nc" id="L144">    server.setStopAtShutdown(true)</span>
<span class="nc" id="L145">    server.setGracefulShutdown(5000)</span>
  }

<span class="nc" id="L148">  class OverflowingSynchronousQueue[E](capacity: Int) extends LinkedBlockingQueue[E](capacity) {</span>
<span class="nc" id="L149">    private val synchronousQueue = new SynchronousQueue[E]()</span>

    // Create a new thread or wake an idled thread
<span class="nc" id="L152">    override def offer(e: E) = synchronousQueue.offer(e)</span>

    // Add to queue
<span class="nc" id="L155">    def offerToOverflowingQueue(e: E) = super.offer(e)</span>

    override def take(): E = {
      // Return tasks from queue, if any, without blocking
<span class="nc" id="L159">      val task = super.poll()</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if (task != null) task else synchronousQueue.take()</span>
    }

    override def poll(timeout: Long, unit: TimeUnit): E = {
      // Return tasks from queue, if any, without blocking
<span class="nc" id="L165">      val task = super.poll()</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      if (task != null) task else synchronousQueue.poll(timeout, unit)</span>
    }
  }

<span class="nc" id="L170">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>